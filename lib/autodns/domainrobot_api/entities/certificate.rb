# frozen_string_literal: true

module Autodns
  module DomainrobotApi
    # Represents an SSL/TLS certificate in AutoDNS
    class Certificate < BaseEntity
      def self.resource_path
        'certificate'
      end

      # Certificate product type
      def product
        attributes[:product]
      end

      # Certificate type (e.g., DV, OV, EV)
      def type
        attributes[:type]
      end

      # Common name (primary domain)
      def common_name
        attributes[:commonName] || attributes[:common_name]
      end

      # Subject alternative names (additional domains)
      def san
        attributes[:san] || attributes[:subjectAlternativeNames] || []
      end
      alias subject_alternative_names san

      # Certificate status
      def status
        attributes[:status]
      end

      # Order status
      def order_status
        attributes[:orderStatus] || attributes[:order_status]
      end

      # Certificate serial number
      def serial_number
        attributes[:serialNumber] || attributes[:serial_number]
      end

      # Validity start date
      def valid_from
        parse_datetime(attributes[:validFrom] || attributes[:valid_from])
      end

      # Validity end date
      def valid_until
        parse_datetime(attributes[:validUntil] || attributes[:valid_until] || attributes[:expire])
      end

      # Certificate data (PEM format)
      def certificate
        attributes[:certificate]
      end

      # CSR (Certificate Signing Request)
      def csr
        attributes[:csr]
      end

      # Private key (if generated by AutoDNS)
      def private_key
        attributes[:privateKey] || attributes[:private_key]
      end

      # Technical contact
      def admin_contact
        association(:adminContact, 'Contact')
      end

      # Organization contact
      def org_contact
        association(:orgContact, 'Contact')
      end

      # Created timestamp
      def created_at
        parse_datetime(attributes[:created])
      end

      # Updated timestamp
      def updated_at
        parse_datetime(attributes[:updated])
      end

      def to_s
        "Certificate ##{id} (#{common_name})"
      end

      # --- Certificate Operations ---

      # Reissue a certificate with new CSR
      # @return [Job] the async job
      def reissue!
        raise ArgumentError, 'Certificate ID required' unless id

        response = client.put("#{self.class.resource_path}/#{id}", body: to_h)
        Job.new(response[:data]&.first || {}, client: client)
      end

      # Renew a certificate
      # @return [Job] the async job
      def renew!
        raise ArgumentError, 'Certificate ID required' unless id

        response = client.put("#{self.class.resource_path}/#{id}/_renew", body: to_h)
        Job.new(response[:data]&.first || {}, client: client)
      end

      # Update certificate comment
      # @param comment [String] the new comment
      def update_comment!(comment)
        raise ArgumentError, 'Certificate ID required' unless id

        client.put("#{self.class.resource_path}/#{id}/_comment", body: { comment: comment })
        true
      end

      # --- Class methods for certificate operations ---

      class << self
        # Order a certificate in realtime (for certain DV products only)
        # @param client [Client] the API client
        # @param certificate_data [Hash] certificate order data
        # @return [Certificate] the issued certificate
        def realtime(client, certificate_data)
          response = client.post("#{resource_path}/_realtime", body: certificate_data)
          new(response[:data]&.first || {}, client: client)
        end

        # Prepare order - check CSR and generate DCV data
        # Should be called before create, realtime, reissue, or renew
        # @param client [Client] the API client
        # @param certificate_data [Hash] certificate data with CSR
        # @return [Hash] prepared certificate data with DCV info
        def prepare_order(client, certificate_data)
          response = client.post("#{resource_path}/_prepareOrder", body: certificate_data)
          response[:data]&.first || {}
        end
      end

      private

      def parse_datetime(value)
        return nil if value.nil? || value.to_s.empty?

        DateTime.parse(value.to_s)
      rescue ArgumentError
        nil
      end
    end
  end
end
